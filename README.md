# 贪心算法
> 贪心算法的本质就是局部最优推导出全局最优，是一种在每一步选择中都采取在当前看来是最好的选择，不从整体上对问题进行分析，从局部出发，通过不断寻找问题的最优解来解决整体问题的方法。

## 贪心算法的应用场景
1. 分发饼干

    假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。
    
    对每个孩子i，都有一个胃口值g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j]。如果 s[j]>=g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

    [] 解释：
    局部最优解是大饼干喂给胃口大的小孩，全局最优就是喂饱尽可能多的小孩。

    [] 解题思路：
    可以尝试使用贪心策略，先将饼干数组和小孩数组排序。然后从后向前遍历小孩数组，用大饼干优先满足胃口大的，并统计满足小孩的数量。

2. 摆动序列

    如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3)  是正负交替出现的。相反, [1,4,7,2,5]  和  [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。

    [] 解释：
    最优解其实就是获取最多的局部峰值，那么局部最优就是删除单调坡度上的节点(不包括单调坡度两端的节点)，那么这个坡度就可以有两个局部峰值。
    
    [] 解题思路：

    1) 上下坡中有平坡
    2) 数组首尾两端
    3) 单调坡中有平坡

3. 最大子序和

    给定一个整数数组nums,找到一个具有最大和的连续子数组(子数组最少包含一个元素)，返回其最大和

    [] 解释:
    局部最优：当前连续和为负数的时候立刻放弃，从下一个元素重新计算连续和，因为负数加上下一个元素连续和只会越来越小。全局最优：选取最大连续和。

    [] 解题思路:

    很简单的想法就是只要前面相加为负数了，就从0开始，前面所有全都放弃。并且要让前面的结果和当前的结果作比较得出最大值

4. 买卖股票的最佳时机

    给定一个数组，它的第  i 个元素是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

    [] 解释：局部最优是相减是正值，得到全局正值

    [] 解题思路：只收集有正利润的时候就是贪心

5. 跳跃游戏

    给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个位置。

    [] 解释:
        在每一个区间里寻找下一步的最大步数，就是全局的最大步数
    
    [] 重要的知识点:
        
        这里有一个重要的知识点，对于js来说，let是可变量，那么在for循环的时候如果使用了let的变量在for循环之后才会销毁，也就是说，在for里面重新给这个变量赋值，这个for循环就会持续进行，直到这个变量不再改变为止，或者return 为止。

        `
            function func(arr) {
                let current = 0;
                for (let i = 0; i <= current; i++) {
                    current = Math.max(arr[i] + i, current); // 持续变长
                    if (current >= arr.length - 1) return true;
                }
                return false;
            }
        `
6. 跳跃游戏 II

    给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。你的目标是使用最少的跳跃次数到达数组的最后一个位置。

    []解释：局部最优解就是当前范围里(就是i === curentIndex)，找到下一步的最大值，然后步数加一，并且把当前的范围改成这个下一步的最大值(curIndex = nextIndex)。注意的点就是这里改变的是索引，数组里的值也是索引所以就有了max(num[i] + i, nextIndex)

    []解题思路： 以最小的步数，增加最大的覆盖范围，直到覆盖范围覆盖了终点，这个范围内最少步数一定可以跳到，不用管具体是怎么跳的，不纠结于一步究竟跳到一个单位还是两个单位。

7. K次取反后最大化的数组和

    给定一个整数数组 A，我们只能用以下方法修改该数组：我们选择某个索引 i 并将 A[i] 替换为 -A[i]，然后总共重复这个过程 K 次。（我们可以多次选择同一个索引 i。）以这种方式修改数组后，返回数组可能的最大和。

    []解释：首先要先把所有的负值都变成正值；那么如果将负数都转变为正数了，K依然大于0，此时的问题是一个有序正整数序列，如何转变K次正负，让 数组和 达到最大。这又是另外一个贪心，将所有的正数从大到小排列，然后更改小的值
    1) 先将所有负值都变为正数
    2) 如果key还有，那就将最小的正值变为负数
    3) 全部都是负数，且所有都遍历一遍之后，key还是有剩下的

    []解题思路：最大和其实是关键,不需要管次序只需要最大和就好。其中比较重要的点是，之前加上的值，后面要记的减两遍。

8. 加油站

    在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。

    []解释: 



    []解题思路: 

    1) 加油站的汽油总量比需要的少，就走不完一圈
    2) 加油站的汽油总量比需要的多，就能走完一圈：
        加油站的两个相隔的汽油差，减去需要的汽油差，如果油箱剩余的汽油量小于0，到i为止，就是从i开始出发，然后遍历到一圈为止。看油箱剩余的汽油量，小于零就返回-1，否则返回i。

9. 分发糖果

    老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。你需要按照以下要求，帮助老师给这些孩子分发糖果：每个孩子至少分配到 1 个糖果。相邻的孩子中，评分高的孩子必须获得更多的糖果。那么这样下来，老师至少需要准备多少颗糖果呢？

    []解释

    []解题思路 分别从两侧，先给所有右侧更多的孩子分发，再给所有左侧最多的孩子分发

10. 柠檬水找零

    在柠檬水摊上，每一杯柠檬水的售价为 5 美元。顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。注意，一开始你手头没有任何零钱。如果你能给每位顾客正确找零，返回 true ，否则返回 false 。

    []解释

    []解题思路: 
     1) 5元就存下
     2）10元优先给5元
     3) 20元优先给10元 

11. 根据身高重建队列

    假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。

    []解释 

    []解题思路

    



# 动态规划

# 回溯算法

# 递归

# 排序

# 二分查找

# 哈希表

# 图论

# 字符串

# 链表

# 树

# 堆

# 并查集

